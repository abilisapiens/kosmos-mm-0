import numpy as np
import pandas as pd

class VulnerabilityCalculator:
    """
    Calculates the severity of and vulnerability to the seven major asteroid
    impact effects based on the ARMOR2 (Rumpf et al., 2017) and Collins et al.
    (2005) papers.
    """

    def __init__(self):#, distance_km: float): #, case: pd.Series, distance_km: float):  #, entry_result: dict
        """
        Initializes the calculator with a specific impact scenario case and a
        distance from the impact point.

        Args:
            case (pd.Series): A row from the PAIR simulation results DataFrame,
                representing a single impact event.
            distance_km (float): The distance from ground zero in kilometers at
                which to calculate the effects.
        """
        #self.case = case
        #distance
        #--loop
        l_distance_km = [0.001,0.5,1,5,10,50,100,200]
        self.l_distance_m = l_distance_km * 1000
        #--silo
        distance_km = 1
        self.distance_m = distance_km * 1000
        # Constants from papers
        self.P_A = 101325  # Ambient pressure in Pa
        self.C_0 = 330      # Speed of sound in m/s

    def _calculate_overpressure_severity(self, case: pd.Series, entry_result: dict,distance_m : float) -> float:  # /!\ airbust = ground
        """Calculates overpressure shockwave severity in Pascals (Pa)."""
        # in = case
        # ATTENTION : div/0 induit par distance
        energy_kt = case['impact_energy_mt'] * 1000
        if energy_kt <= 0:
            return 0.0

        is_airburst = case.get('burst_altitude_km', 0) > 0

        if not is_airburst:  # Ground impact
            p_x, d_x = 75000, 290
            scaled_distance = distance_m / (energy_kt**(1/3))
            overpressure = (p_x * d_x * energy_kt**(1/3) / (4 * distance_m)) * \
                           (1 + 3 * (d_x * energy_kt**(1/3) / distance_m)**1.3)
            return overpressure
        else: # Airburst
            # This is a simplified model. A full implementation would distinguish
            # between regular and Mach reflection regions.
            # Using the ground impact formula as a proxy for simplicity.
            p_x, d_x = 75000, 290
            scaled_distance = distance_m / (energy_kt**(1/3))
            overpressure = (p_x * d_x * energy_kt**(1/3) / (4 * distance_m)) * \
                           (1 + 3 * (d_x * energy_kt**(1/3) / distance_m)**1.3)
            return overpressure


    def _calculate_wind_severity(self, overpressure_pa: float,distance_m : float) -> float:
        """Calculates high wind severity in meters per second (m/s)."""
        # IN = overpressure ?
        # attention : DIV/0 dans calcul return
        if overpressure_pa <= 0:
            return 0.0
        # From ARMOR2, Equation 10
        numerator = 5 * overpressure_pa * self.C_0
        denominator = (7 * self.P_A) * np.sqrt(1 + (6 * overpressure_pa) / (7 * self.P_A))
        return numerator / denominator if denominator != 0 else 0

    def _calculate_thermal_severity(self, case: pd.Series, entry_result: dict,distance_m : float) -> float:
        """Calculates thermal radiation severity in Joules per square meter (J/m^2)."""
        # IN = case + random
        # attention : div/0 induit par distance
        energy_j = case['impact_energy_mt'] * 4.184e15
        if energy_j <= 0:
            return 0.0
            
        # Luminous efficiency (eta) from PAIR paper (Wheeler et al. 2024)
        luminous_efficiency = 10**np.random.uniform(-4, -2) # Sample between 1e-4 and 1e-2
        
        # From Collins et al. 2005, Equation 34
        thermal_exposure = (luminous_efficiency * energy_j) / (2 * np.pi * distance_m**2)
        return thermal_exposure

    def _calculate_seismic_severity(self, case: pd.Series, entry_result: dict,distance_m : float) -> float:
        """Calculates seismic shaking severity in effective Richter scale magnitude."""
        # IN = case
        energy_j = case['impact_energy_mt'] * 4.184e15
        if energy_j <= 0:
            return 0.0
        # From Collins et al. 2005, Equation 40
        magnitude = 0.67 * np.log10(energy_j) - 5.87
        
        # From Collins et al. 2005, Equation 41
        r_km = distance_m / 1000
        if r_km < 60:
            return magnitude - 0.0238 * r_km
        elif 60 <= r_km < 700:
            return magnitude - 0.0048 * r_km - 1.1644
        else:
            delta = r_km / 6371 # Earth radius
            return magnitude - 1.66 * np.log10(delta) - 6.399


    def _calculate_ejecta_severity(self, case: pd.Series, entry_result: dict, distance_m : float) -> float:
        """Calculates ejecta blanket thickness in meters."""
        # IN = case + simplification
        # This requires transient crater diameter, which is not in the base PAIR output.
        # We'll estimate it based on final crater diameter. D_fr = 1.25 * D_tc
        # This is a simplification.
        final_crater_km = case.get('final_crater_diameter_km', 0)
        if final_crater_km <=0:
             return 0.0
        transient_crater_km = final_crater_km / 1.25
        transient_crater_m = transient_crater_km * 1000

        # From Collins et al. 2005, Equation 47
        if distance_m == 0: return np.inf
        thickness_m = (transient_crater_m**4) / (112 * distance_m**3)
        return thickness_m if distance_m > transient_crater_m / 2 else np.inf

    def _sigmoid(self, x, a, b, c):
        """Generic sigmoid function for vulnerability models."""
        return a / (1 + np.exp(b * (x + c)))

    def calculate_all_vulnerabilities(self, case: pd.Series, entry_result: dict) -> dict:
        """
        Calculates severity and vulnerability for all seven effects and the
        combined vulnerability.
        """
        results = {}

        # 1. Overpressure
        overpressure_sev = self._calculate_overpressure_severity(case, entry_result,self.distance_m)
        overpressure_vuln = self._sigmoid(overpressure_sev, 1.0, -2.424e-5, -4.404e5)
        results['Overpressure'] = {'severity': f"{overpressure_sev/1e3:.2f} kPa", 'vulnerability': overpressure_vuln}

        # 2. High Winds
        wind_sev = self._calculate_wind_severity(overpressure_sev,self.distance_m)
        wind_vuln = self._sigmoid(wind_sev, 1.0, -5.483e-2, -1.124e2)
        results['High Winds'] = {'severity': f"{wind_sev:.2f} m/s", 'vulnerability': wind_vuln}

        # 3. Thermal Radiation
        thermal_sev = self._calculate_thermal_severity(case, entry_result,self.distance_m)
        thermal_vuln = self._sigmoid(thermal_sev, 0.47, -5.623e-6, -7.316e5)
        results['Thermal Radiation'] = {'severity': f"{thermal_sev/1e6:.2f} MJ/m^2", 'vulnerability': thermal_vuln}
        
        # 4. Seismic Shaking
        seismic_sev = self._calculate_seismic_severity(case, entry_result,self.distance_m)
        seismic_vuln = self._sigmoid(seismic_sev, 1.0, -2.516, -8.686)
        results['Seismic Shaking'] = {'severity': f"{seismic_sev:.2f} Richter", 'vulnerability': seismic_vuln}

        # 5. Cratering
        final_crater_km = case.get('final_crater_diameter_km', 0)
        is_in_crater = self.distance_m < (final_crater_km * 1000 / 2)
        crater_vuln = 1.0 if is_in_crater else 0.0
        results['Cratering'] = {'severity': "Inside Crater" if is_in_crater else "Outside Crater", 'vulnerability': crater_vuln}

        # 6. Ejecta
        ejecta_sev = self._calculate_ejecta_severity(case, entry_result,self.distance_m)
        ejecta_load_kpa = ejecta_sev * 1600 * 9.81 / 1000 # thickness * density * g
        ejecta_vuln = 0.078 / ((1 + np.exp(-1.37 * (ejecta_load_kpa - 3.14)))**4.6)
        results['Ejecta'] = {'severity': f"{ejecta_sev:.2f} m", 'vulnerability': ejecta_vuln}

        # 7. Tsunami (Placeholder)
        # A full model is complex. We'll set vulnerability to 0 for non-ocean impacts.
        tsunami_vuln = 0.0
        results['Tsunami'] = {'severity': "N/A (Land Impact)", 'vulnerability': tsunami_vuln}

        # Combined Vulnerability
        survivability = 1.0
        for effect in results:
            survivability *= (1 - results[effect]['vulnerability'])
        
        combined_vulnerability = 1 - survivability
        results['Combined'] = {'severity': "Overall", 'vulnerability': combined_vulnerability}

        return results
    
    def loopdistance_calculate_all_vulnerabilities_dictdict(self, case: pd.Series, entry_result: dict) -> dict:
        """
        Calculates severity and vulnerability for all seven effects across all distances,
        then computes the combined vulnerability at each distance.
        """
        results = {
            'Overpressure': {'severity': {}, 'vulnerability': {}},
            'High Winds': {'severity': {}, 'vulnerability': {}},
            'Thermal Radiation': {'severity': {}, 'vulnerability': {}},
            'Seismic Shaking': {'severity': {}, 'vulnerability': {}},
            'Cratering': {'severity': {}, 'vulnerability': {}},
            'Ejecta': {'severity': {}, 'vulnerability': {}},
            'Tsunami': {'severity': {}, 'vulnerability': {}},
            'Combined': {'severity': "Overall", 'vulnerability': {}},
        }

        for distance_m in self.l_distance_m:
            # --- 1. Overpressure ---
            overpressure_sev = self._calculate_overpressure_severity(case, entry_result, distance_m)
            overpressure_vuln = self._sigmoid(overpressure_sev, 1.0, -2.424e-5, -4.404e5)
            results['Overpressure']['severity'][distance_m] = overpressure_sev
            results['Overpressure']['vulnerability'][distance_m] = overpressure_vuln

            # --- 2. High Winds ---
            wind_sev = self._calculate_wind_severity(overpressure_sev, distance_m)
            wind_vuln = self._sigmoid(wind_sev, 1.0, -5.483e-2, -1.124e2)
            results['High Winds']['severity'][distance_m] = wind_sev
            results['High Winds']['vulnerability'][distance_m] = wind_vuln

            # --- 3. Thermal Radiation ---
            thermal_sev = self._calculate_thermal_severity(case, entry_result, distance_m)
            thermal_vuln = self._sigmoid(thermal_sev, 0.47, -5.623e-6, -7.316e5)
            results['Thermal Radiation']['severity'][distance_m] = thermal_sev
            results['Thermal Radiation']['vulnerability'][distance_m] = thermal_vuln

            # --- 4. Seismic Shaking ---
            seismic_sev = self._calculate_seismic_severity(case, entry_result, distance_m)
            seismic_vuln = self._sigmoid(seismic_sev, 1.0, -2.516, -8.686)
            results['Seismic Shaking']['severity'][distance_m] = seismic_sev
            results['Seismic Shaking']['vulnerability'][distance_m] = seismic_vuln

            # --- 5. Cratering ---
            final_crater_km = case.get('final_crater_diameter_km', 0)
            is_in_crater = distance_m < (final_crater_km * 1000 / 2)
            crater_vuln = 1.0 if is_in_crater else 0.0
            results['Cratering']['severity'][distance_m] = "Inside Crater" if is_in_crater else "Outside Crater"
            results['Cratering']['vulnerability'][distance_m] = crater_vuln

            # --- 6. Ejecta ---
            ejecta_sev = self._calculate_ejecta_severity(case, entry_result, distance_m)
            ejecta_load_kpa = ejecta_sev * 1600 * 9.81 / 1000  # thickness * density * g
            ejecta_vuln = 0.078 / ((1 + np.exp(-1.37 * (ejecta_load_kpa - 3.14))) ** 4.6)
            results['Ejecta']['severity'][distance_m] = ejecta_sev
            results['Ejecta']['vulnerability'][distance_m] = ejecta_vuln

            # --- 7. Tsunami (Placeholder) ---
            tsunami_vuln = 0.0
            results['Tsunami']['severity'][distance_m] = "N/A (Land Impact)"
            results['Tsunami']['vulnerability'][distance_m] = tsunami_vuln

            # --- Combined vulnerability at this distance ---
            survivability = 1.0
            for effect in ['Overpressure', 'High Winds', 'Thermal Radiation',
                        'Seismic Shaking', 'Cratering', 'Ejecta', 'Tsunami']:
                vuln = results[effect]['vulnerability'][distance_m]
                # some are strings ("Inside Crater"), skip those
                if isinstance(vuln, (int, float)):
                    survivability *= (1 - vuln)
            combined_vuln = 1 - survivability
            results['Combined']['vulnerability'][distance_m] = combined_vuln

        return results
    
    def flatten_vulnerability_results_dictlist(d_results: dict, b_pivot = True) -> pd.DataFrame:
        records = []
        for effect, data in d_results.items():
            distances = data["distance"]
            severities = data["severity"]
            vulnerabilities = data["vulnerability"]

            for d, s, v in zip(distances, severities, vulnerabilities):
                records.append({
                    "effect": effect,
                    "distance": d,
                    "severity": s,
                    "vulnerability": v
                })
        df = pd.DataFrame(records)
        if b_pivot:
            df = df.pivot(index="distance", columns="effect", values="vulnerability")

        return df

    def loopdistance_calculate_all_vulnerabilities_dictlist2df(self, case: pd.Series, entry_result: dict,b_pivot=True) -> dict:
        """
        Calculates severity and vulnerability for all effects across all distances.
        Returns a dict structured per effect:
        {
            "Overpressure": {"distance": [...], "severity": [...], "vulnerability": [...]},
            "High Winds": {"distance": [...], "severity": [...], "vulnerability": [...]},
            ...
            "Combined": {"distance": [...], "severity": ["Overall", ...], "vulnerability": [...]}
        }
        """
        distances = self.l_distance_m

        # Initialize output structure
        results = {
            'Overpressure': {'distance': [], 'severity': [], 'vulnerability': []},
            'High Winds': {'distance': [], 'severity': [], 'vulnerability': []},
            'Thermal Radiation': {'distance': [], 'severity': [], 'vulnerability': []},
            'Seismic Shaking': {'distance': [], 'severity': [], 'vulnerability': []},
            'Cratering': {'distance': [], 'severity': [], 'vulnerability': []},
            'Ejecta': {'distance': [], 'severity': [], 'vulnerability': []},
            'Tsunami': {'distance': [], 'severity': [], 'vulnerability': []},
            'Combined': {'distance': [], 'severity': [], 'vulnerability': []},
        }

        for distance_m in distances:
            # --- 1. Overpressure ---
            overpressure_sev = self._calculate_overpressure_severity(case, entry_result, distance_m)
            overpressure_vuln = self._sigmoid(overpressure_sev, 1.0, -2.424e-5, -4.404e5)
            results['Overpressure']['distance'].append(distance_m)
            results['Overpressure']['severity'].append(overpressure_sev)
            results['Overpressure']['vulnerability'].append(overpressure_vuln)

            # --- 2. High Winds ---
            wind_sev = self._calculate_wind_severity(overpressure_sev, distance_m)
            wind_vuln = self._sigmoid(wind_sev, 1.0, -5.483e-2, -1.124e2)
            results['High Winds']['distance'].append(distance_m)
            results['High Winds']['severity'].append(wind_sev)
            results['High Winds']['vulnerability'].append(wind_vuln)

            # --- 3. Thermal Radiation ---
            thermal_sev = self._calculate_thermal_severity(case, entry_result, distance_m)
            thermal_vuln = self._sigmoid(thermal_sev, 0.47, -5.623e-6, -7.316e5)
            results['Thermal Radiation']['distance'].append(distance_m)
            results['Thermal Radiation']['severity'].append(thermal_sev)
            results['Thermal Radiation']['vulnerability'].append(thermal_vuln)

            # --- 4. Seismic Shaking ---
            seismic_sev = self._calculate_seismic_severity(case, entry_result, distance_m)
            seismic_vuln = self._sigmoid(seismic_sev, 1.0, -2.516, -8.686)
            results['Seismic Shaking']['distance'].append(distance_m)
            results['Seismic Shaking']['severity'].append(seismic_sev)
            results['Seismic Shaking']['vulnerability'].append(seismic_vuln)

            # --- 5. Cratering ---
            final_crater_km = case.get('final_crater_diameter_km', 0)
            is_in_crater = distance_m < (final_crater_km * 1000 / 2)
            crater_vuln = 1.0 if is_in_crater else 0.0
            results['Cratering']['distance'].append(distance_m)
            results['Cratering']['severity'].append("Inside Crater" if is_in_crater else "Outside Crater")
            results['Cratering']['vulnerability'].append(crater_vuln)

            # --- 6. Ejecta ---
            ejecta_sev = self._calculate_ejecta_severity(case, entry_result, distance_m)
            ejecta_load_kpa = ejecta_sev * 1600 * 9.81 / 1000  # thickness * density * g
            ejecta_vuln = 0.078 / ((1 + np.exp(-1.37 * (ejecta_load_kpa - 3.14))) ** 4.6)
            results['Ejecta']['distance'].append(distance_m)
            results['Ejecta']['severity'].append(ejecta_sev)
            results['Ejecta']['vulnerability'].append(ejecta_vuln)

            # --- 7. Tsunami (Placeholder) ---
            results['Tsunami']['distance'].append(distance_m)
            results['Tsunami']['severity'].append("N/A (Land Impact)")
            results['Tsunami']['vulnerability'].append(0.0)

            # --- 8. Combined vulnerability ---
            survivability = 1.0
            for effect in ['Overpressure', 'High Winds', 'Thermal Radiation',
                        'Seismic Shaking', 'Cratering', 'Ejecta', 'Tsunami']:
                vuln = results[effect]['vulnerability'][-1]
                if isinstance(vuln, (int, float)):
                    survivability *= (1 - vuln)
            combined_vuln = 1 - survivability
            results['Combined']['distance'].append(distance_m)
            results['Combined']['severity'].append("Overall")
            results['Combined']['vulnerability'].append(combined_vuln)

        df = self.flatten_vulnerability_results_dictlist(d_results=results,b_pivot=b_pivot)

        return df

