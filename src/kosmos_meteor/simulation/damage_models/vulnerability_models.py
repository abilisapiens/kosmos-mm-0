import numpy as np
import pandas as pd

class VulnerabilityCalculator:
    """
    Calculates the severity of and vulnerability to the seven major asteroid
    impact effects based on the ARMOR2 (Rumpf et al., 2017) and Collins et al.
    (2005) papers.
    """

    def __init__(self): #, case: pd.Series, distance_km: float):  #, entry_result: dict
        """
        Initializes the calculator with a specific impact scenario case and a
        distance from the impact point.

        Args:
            case (pd.Series): A row from the PAIR simulation results DataFrame,
                representing a single impact event.
            distance_km (float): The distance from ground zero in kilometers at
                which to calculate the effects.
        """
        #self.case = case
        self.distance_m = 10 #distance_km * 1000
        # Constants from papers
        self.P_A = 101325  # Ambient pressure in Pa
        self.C_0 = 330      # Speed of sound in m/s

    def _calculate_overpressure_severity(self, case: pd.Series, entry_result: dict) -> float:  # /!\ airbust = ground
        """Calculates overpressure shockwave severity in Pascals (Pa)."""
        # in = case
        energy_kt = case['impact_energy_mt'] * 1000
        if energy_kt <= 0:
            return 0.0

        is_airburst = case.get('burst_altitude_km', 0) > 0

        if not is_airburst:  # Ground impact
            p_x, d_x = 75000, 290
            scaled_distance = self.distance_m / (energy_kt**(1/3))
            overpressure = (p_x * d_x * energy_kt**(1/3) / (4 * self.distance_m)) * \
                           (1 + 3 * (d_x * energy_kt**(1/3) / self.distance_m)**1.3)
            return overpressure
        else: # Airburst
            # This is a simplified model. A full implementation would distinguish
            # between regular and Mach reflection regions.
            # Using the ground impact formula as a proxy for simplicity.
            p_x, d_x = 75000, 290
            scaled_distance = self.distance_m / (energy_kt**(1/3))
            overpressure = (p_x * d_x * energy_kt**(1/3) / (4 * self.distance_m)) * \
                           (1 + 3 * (d_x * energy_kt**(1/3) / self.distance_m)**1.3)
            return overpressure


    def _calculate_wind_severity(self, overpressure_pa: float) -> float:
        """Calculates high wind severity in meters per second (m/s)."""
        # IN = overpressure ?
        if overpressure_pa <= 0:
            return 0.0
        # From ARMOR2, Equation 10
        numerator = 5 * overpressure_pa * self.C_0
        denominator = (7 * self.P_A) * np.sqrt(1 + (6 * overpressure_pa) / (7 * self.P_A))
        return numerator / denominator if denominator != 0 else 0

    def _calculate_thermal_severity(self, case: pd.Series, entry_result: dict) -> float:
        """Calculates thermal radiation severity in Joules per square meter (J/m^2)."""
        # IN = case + random
        energy_j = case['impact_energy_mt'] * 4.184e15
        if energy_j <= 0:
            return 0.0
            
        # Luminous efficiency (eta) from PAIR paper (Wheeler et al. 2024)
        luminous_efficiency = 10**np.random.uniform(-4, -2) # Sample between 1e-4 and 1e-2
        
        # From Collins et al. 2005, Equation 34
        thermal_exposure = (luminous_efficiency * energy_j) / (2 * np.pi * self.distance_m**2)
        return thermal_exposure

    def _calculate_seismic_severity(self, case, entry_result) -> float:
        """Calculates seismic shaking severity in effective Richter scale magnitude."""
        # IN = case
        energy_j = case['impact_energy_mt'] * 4.184e15
        if energy_j <= 0:
            return 0.0
        # From Collins et al. 2005, Equation 40
        magnitude = 0.67 * np.log10(energy_j) - 5.87
        
        # From Collins et al. 2005, Equation 41
        r_km = self.distance_m / 1000
        if r_km < 60:
            return magnitude - 0.0238 * r_km
        elif 60 <= r_km < 700:
            return magnitude - 0.0048 * r_km - 1.1644
        else:
            delta = r_km / 6371 # Earth radius
            return magnitude - 1.66 * np.log10(delta) - 6.399


    def _calculate_ejecta_severity(self, case, entry_result) -> float:
        """Calculates ejecta blanket thickness in meters."""
        # IN = case + simplification
        # This requires transient crater diameter, which is not in the base PAIR output.
        # We'll estimate it based on final crater diameter. D_fr = 1.25 * D_tc
        # This is a simplification.
        final_crater_km = case.get('final_crater_diameter_km', 0)
        if final_crater_km <=0:
             return 0.0
        transient_crater_km = final_crater_km / 1.25
        transient_crater_m = transient_crater_km * 1000

        # From Collins et al. 2005, Equation 47
        if self.distance_m == 0: return np.inf
        thickness_m = (transient_crater_m**4) / (112 * self.distance_m**3)
        return thickness_m if self.distance_m > transient_crater_m / 2 else np.inf

    def _sigmoid(self, x, a, b, c):
        """Generic sigmoid function for vulnerability models."""
        return a / (1 + np.exp(b * (x + c)))

    def calculate_all_vulnerabilities(self, case, entry_result) -> dict:
        """
        Calculates severity and vulnerability for all seven effects and the
        combined vulnerability.
        """
        results = {}

        # 1. Overpressure
        overpressure_sev = self._calculate_overpressure_severity(case, entry_result)
        overpressure_vuln = self._sigmoid(overpressure_sev, 1.0, -2.424e-5, -4.404e5)
        results['Overpressure'] = {'severity': f"{overpressure_sev/1e3:.2f} kPa", 'vulnerability': overpressure_vuln}

        # 2. High Winds
        wind_sev = self._calculate_wind_severity(overpressure_sev)
        wind_vuln = self._sigmoid(wind_sev, 1.0, -5.483e-2, -1.124e2)
        results['High Winds'] = {'severity': f"{wind_sev:.2f} m/s", 'vulnerability': wind_vuln}

        # 3. Thermal Radiation
        thermal_sev = self._calculate_thermal_severity(case, entry_result)
        thermal_vuln = self._sigmoid(thermal_sev, 0.47, -5.623e-6, -7.316e5)
        results['Thermal Radiation'] = {'severity': f"{thermal_sev/1e6:.2f} MJ/m^2", 'vulnerability': thermal_vuln}
        
        # 4. Seismic Shaking
        seismic_sev = self._calculate_seismic_severity(case, entry_result)
        seismic_vuln = self._sigmoid(seismic_sev, 1.0, -2.516, -8.686)
        results['Seismic Shaking'] = {'severity': f"{seismic_sev:.2f} Richter", 'vulnerability': seismic_vuln}

        # 5. Cratering
        final_crater_km = case.get('final_crater_diameter_km', 0)
        is_in_crater = self.distance_m < (final_crater_km * 1000 / 2)
        crater_vuln = 1.0 if is_in_crater else 0.0
        results['Cratering'] = {'severity': "Inside Crater" if is_in_crater else "Outside Crater", 'vulnerability': crater_vuln}

        # 6. Ejecta
        ejecta_sev = self._calculate_ejecta_severity(case, entry_result)
        ejecta_load_kpa = ejecta_sev * 1600 * 9.81 / 1000 # thickness * density * g
        ejecta_vuln = 0.078 / ((1 + np.exp(-1.37 * (ejecta_load_kpa - 3.14)))**4.6)
        results['Ejecta'] = {'severity': f"{ejecta_sev:.2f} m", 'vulnerability': ejecta_vuln}

        # 7. Tsunami (Placeholder)
        # A full model is complex. We'll set vulnerability to 0 for non-ocean impacts.
        tsunami_vuln = 0.0
        results['Tsunami'] = {'severity': "N/A (Land Impact)", 'vulnerability': tsunami_vuln}

        # Combined Vulnerability
        survivability = 1.0
        for effect in results:
            survivability *= (1 - results[effect]['vulnerability'])
        
        combined_vulnerability = 1 - survivability
        results['Combined'] = {'severity': "Overall", 'vulnerability': combined_vulnerability}

        return results
