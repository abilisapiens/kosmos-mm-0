import numpy as np
import pandas as pd
import math

class VulnerabilityCalculator:
    """
    Calculates the severity of and vulnerability to the seven major asteroid
    impact effects based on the ARMOR2 (Rumpf et al., 2017) and Collins et al.
    (2005) papers.
    """

    def __init__(self): #, case: pd.Series, distance_km: float):  #, entry_result: dict
        """
        Initializes the calculator with a specific impact scenario case and a
        distance from the impact point.

        Args:
            case (pd.Series): A row from the PAIR simulation results DataFrame,
                representing a single impact event.
            distance_km (float): The distance from ground zero in kilometers at
                which to calculate the effects.
        """

        # Constants from papers
        self.P_A = 101325  # Ambient pressure in Pa
        self.C_0 = 330      # Speed of sound in m/s
        
    


    def _calculate_overpressure_severity(self, distance_local_m:float, case: pd.Series, entry_result: dict, cr_result: dict) -> float:  # /!\ airbust = ground
        """Calculates overpressure shockwave severity in Pascals (Pa)."""
        print(f"""distance_local_m={distance_local_m}""")
        energy_kt = cr_result.get('impact_energy_kt' ,0)
        print(f"""energy_kt = {energy_kt}; check not 0""")       
        is_airburst = cr_result.get('airburst_bool',0)
        print(f"""is_airburst = {is_airburst}; check not false always""")
        burst_altitude_m=cr_result['burst_altitude_km']*1000     

        if energy_kt <= 0:
            return 0.0

        if not is_airburst:  # Ground impact
            p_x, d_x = 75000, 290
            overpressure_pa = (p_x * d_x * energy_kt**(1/3) / (4)) * (1 + 3 * (d_x * energy_kt**(1/3) / distance_local_m)**1.3)
            return overpressure_pa
        else: # Airburst
            P0 = 101300  # Reference pressure in Pascals (1 atm)
            a = 1.8e6    # Empirical constant from Collins et al.
            b = 1.3      # Empirical exponent
            # Effective slant distance
            R_eff = np.sqrt(distance_local_m**2 + burst_altitude_m**2)
            # Scaled distance
            Z = R_eff / (energy_kt**(1/3))
            # Overpressure in Pascals
            p0_armor=3.14*pow(10,11)*pow(burst_altitude_m,-2.6)+1.8*pow(10,7)*pow(burst_altitude_m,-1.13)
            b_armor = 34.87*pow(burst_altitude_m,-1.73)
            overpressure_1_pa = a * np.exp(Z*(-b))   
            print(f""" overpressure_1_pa={overpressure_1_pa}""")
            overpressure_pa = p0_armor * np.exp(-b_armor*Z) 
            print(overpressure_pa)           
            print(type(Z));print(Z)
            print(type(a));print(a)
            print("p0_armor =",p0_armor)            
            print("Type of Z:", type(Z))
            print("Type of b:", type(b))
            print("Z =", Z)
            print("b =", b)
            print("b_armor =", 34.87*pow(burst_altitude_m,-1.73))

            return overpressure_pa


    def _calculate_wind_severity(self, overpressure_pa: float) -> float:
        """Calculates high wind severity in meters per second (m/s)."""
        # IN = overpressure ?
        if overpressure_pa <= 0:
            return 0.0
        # From ARMOR2, Equation 10
        numerator = 5 * overpressure_pa * self.C_0
        denominator = (7 * self.P_A) * np.sqrt(1 + (6 * overpressure_pa) / (7 * self.P_A))
        return numerator / denominator if denominator != 0 else 0
    


    def _calculate_thermal_severity(self, distance_local_m:float, case: pd.Series, entry_result: dict, cr_result: dict) -> float:
        """Calculates thermal radiation severity in Joules per square meter (J/m^2)."""
        # IN = case + random
        energy_j = cr_result['impact_energy_j'] 
        is_airburst = cr_result['airburst_bool']
        burst_altitude_m=cr_result['burst_altitude_km']*1000

        R= distance_local_m
        # Step 3: Effective blast distance
        R_eff = math.sqrt(R**2 + burst_altitude_m**2) if is_airburst else R
        
        if is_airburst:
            eta = 0.05
        else:
            eta = 0.03

        if energy_j <= 0:
            return 0.0

        # Step 3: Thermal energy
        E_thermal = eta * energy_j

        # Step 4: Fireball radius (yield scaling)
        # Airbursts typically have larger fireballs due to atmospheric expansion
        R_fireball = 0.002 * E_thermal**(1/3)

        # Step 5: Thermal flux at distance R
        flux = E_thermal / (2 * math.pi * R_eff**2)

        # Step 6: Thermal dose (J/mÂ²)
        thermal_exposure_jm2 = flux  # assuming instantaneous release

        return thermal_exposure_jm2
    


    def _calculate_seismic_severity(self, distance_local_m:float, case, entry_result: dict, cr_result: dict) -> float:
        """Calculates seismic shaking severity in effective Richter scale magnitude."""
        # IN = case
        energy_j = cr_result['impact_energy_j']

        if energy_j <= 0:
            return 0.0
        # From Collins et al. 2005, Equation 40
        magnitude = 0.67 * np.log10(energy_j) - 5.87
        
        # From Collins et al. 2005, Equation 41
        r_km = distance_local_m / 1000
        if r_km < 60:
            return magnitude - 0.0238 * r_km
        elif 60 <= r_km < 700:
            return magnitude - 0.0048 * r_km - 1.1644
        else:
            delta = r_km / 6371 # Earth radius
            return magnitude - 1.66 * np.log10(delta) - 6.399


    def _calculate_ejecta_severity(self, distance_local_m:float, case, entry_result: dict, cr_result: dict) -> float:
        """Calculates ejecta blanket thickness in meters."""
        # IN = case + simplification
        # This requires transient crater diameter, which is not in the base PAIR output.
        # We'll estimate it based on final crater diameter. D_fr = 1.25 * D_tc
        # This is a simplification.
        final_crater_km = cr_result.get('final_crater_diameter_km', 0)
        if final_crater_km <=0:
             return 0.0
        transient_crater_km = final_crater_km / 1.25
        transient_crater_m = transient_crater_km * 1000

        # From Collins et al. 2005, Equation 47
        if distance_local_m == 0: return np.inf
        thickness_m = (transient_crater_m**4) / (112 * distance_local_m**3)
        return thickness_m if distance_local_m > transient_crater_m / 2 else np.inf

    def _sigmoid(self, x, a, b, c):
        """Generic sigmoid function for vulnerability models."""
        return a / (1 + np.exp(b * (x + c)))

    def calculate_all_vulnerabilities(self, case, entry_result: dict, cr_result: dict) -> dict:
        """
        Calculates severity and vulnerability for all seven effects and the
        combined vulnerability.
        """
        results = {}

        distance_km = np.linspace(1, 100, 50)
        distance_local_m = pd.Series(distance_km * 1000, dtype='float')

        for d_m in distance_local_m:
            # 1. Overpressure
            overpressure_sev = self._calculate_overpressure_severity(d_m, case,entry_result, cr_result)
            print(f"""overpressure_sev= {overpressure_sev}""")
            overpressure_vuln = self._sigmoid(overpressure_sev, 1.0, -2.424e-5, -4.404e5)
            results['Overpressure'] = {'distance_km': d_m/1000, 'severity':(f"{overpressure_sev:.2f} Pa"), 'vulnerability': overpressure_vuln}

            # 2. High Winds
            wind_sev = self._calculate_wind_severity(overpressure_sev)
            wind_vuln = self._sigmoid(wind_sev, 1.0, -5.483e-2, -1.124e2)
            results['High Winds'] = {'distance_km': d_m/1000,'severity': f"{wind_sev:.2f} m/s", 'vulnerability': wind_vuln}

            # 3. Thermal Radiation
            thermal_sev = self._calculate_thermal_severity( d_m, case, entry_result, cr_result)
            thermal_vuln = self._sigmoid(thermal_sev, 0.47, -5.623e-6, -7.316e5)
            results['Thermal Radiation'] = {'distance_km':d_m/1000,'severity': f"{thermal_sev/1e6:.2f} MJ/m^2", 'vulnerability': thermal_vuln}
            
            # 4. Seismic Shaking
            seismic_sev = self._calculate_seismic_severity(d_m, case,entry_result, cr_result)
            seismic_vuln = self._sigmoid(seismic_sev, 1.0, -2.516, -8.686)
            results['Seismic Shaking'] = {'distance_km':d_m/1000,'severity': f"{seismic_sev:.2f} Richter", 'vulnerability': seismic_vuln}

            # 5. Cratering
            final_crater_km = case.get('final_crater_diameter_km', 0)
            is_in_crater = d_m < (final_crater_km * 1000 / 2)
            crater_vuln = 1.0 if is_in_crater else 0.0
            results['Cratering'] = {'distance_km':d_m/1000,'severity': "Inside Crater" if is_in_crater else "Outside Crater", 'vulnerability': crater_vuln}

            # 6. Ejecta
            ejecta_sev = self._calculate_ejecta_severity( d_m, case, entry_result, cr_result)
            ejecta_load_kpa = ejecta_sev * 1600 * 9.81 / 1000 # thickness * density * g
            ejecta_vuln = 0.078 / ((1 + np.exp(-1.37 * (ejecta_load_kpa - 3.14)))**4.6)
            results['Ejecta'] = {'distance_km':d_m/1000,'severity': f"{ejecta_sev:.2f} m", 'vulnerability': ejecta_vuln}

            # 7. Tsunami (Placeholder)
            # A full model is complex. We'll set vulnerability to 0 for non-ocean impacts.
            tsunami_vuln = 0.0
            results['Tsunami'] = {'distance_km':d_m/1000,'severity': "N/A (Land Impact)", 'vulnerability': tsunami_vuln}

            # Combined Vulnerability
            survivability = 1.0
            for effect in results:
                survivability *= (1 - results[effect]['vulnerability'])
            
            combined_vulnerability = 1 - survivability
            results['Combined'] = {'distance_km':d_m/1000,'severity': "Overall", 'vulnerability': combined_vulnerability}

        return results
